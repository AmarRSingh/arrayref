var searchIndex = {};
searchIndex['arrayref'] = {"items":[[0,"","arrayref","This package contains just four macros, which enable the creation\nof array references to portions of arrays or slices (or things\nthat can be sliced).",null,null],[14,"array_ref!","","You can use `array_ref` to generate an array reference to a subset\nof a sliceable bit of data (which could be an array, or a slice,\nor a Vec).",null,null],[14,"array_refs!","","You can use `array_refs` to generate a series of array references\nto an input array reference.  The idea is if you want to break an\narray into a series of contiguous and non-overlapping arrays.\n`array_refs` is a bit funny in that it insists on slicing up the\n*entire* array.  This is intentional, as I find it handy to make\nme ensure that my sub-arrays add up to the entire array.  This\nmacro will *never* panic, since the sizes are all checked at\ncompile time.",null,null],[14,"mut_array_refs!","","You can use `mut_array_refs` to generate a series of mutable array\nreferences to an input mutable array reference.  The idea is if\nyou want to break an array into a series of contiguous and\nnon-overlapping mutable array references.  Like `array_refs!`,\n`mut_array_refs!` is a bit funny in that it insists on slicing up\nthe *entire* array.  This is intentional, as I find it handy to\nmake me ensure that my sub-arrays add up to the entire array.\nThis macro will *never* panic, since the sizes are all checked at\ncompile time.",null,null],[14,"array_mut_ref!","","You can use `array_mut_ref` to generate a mutable array reference\nto a subset of a sliceable bit of data (which could be an array,\nor a slice, or a Vec).",null,null]],"paths":[]};
initSearch(searchIndex);
